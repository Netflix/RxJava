//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel-doppl/RxJava/src/test/java/rx/plugins/RxJavaSchedulersHookTest.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "RxFunctionsAction0.h"
#include "RxInternalSchedulersSchedulerLifecycle.h"
#include "RxPluginsRxJavaSchedulersHook.h"
#include "RxPluginsRxJavaSchedulersHookTest.h"
#include "RxScheduler.h"
#include "RxSubscription.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/Runnable.h"
#include "java/lang/Thread.h"
#include "java/lang/annotation/Annotation.h"
#include "java/util/concurrent/CountDownLatch.h"
#include "java/util/concurrent/ThreadFactory.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/atomic/AtomicReference.h"
#include "org/junit/Assert.h"
#include "org/junit/Test.h"

__attribute__((unused)) static IOSObjectArray *RxPluginsRxJavaSchedulersHookTest__Annotations$0();

__attribute__((unused)) static IOSObjectArray *RxPluginsRxJavaSchedulersHookTest__Annotations$1();

__attribute__((unused)) static IOSObjectArray *RxPluginsRxJavaSchedulersHookTest__Annotations$2();

__attribute__((unused)) static IOSObjectArray *RxPluginsRxJavaSchedulersHookTest__Annotations$3();

@interface RxPluginsRxJavaSchedulersHookTest_$1 : NSObject < JavaUtilConcurrentThreadFactory > {
 @public
  JavaUtilConcurrentAtomicAtomicReference *val$threadRef_;
}

- (JavaLangThread *)newThreadWithJavaLangRunnable:(id<JavaLangRunnable>)r OBJC_METHOD_FAMILY_NONE;

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0;

@end

J2OBJC_EMPTY_STATIC_INIT(RxPluginsRxJavaSchedulersHookTest_$1)

J2OBJC_FIELD_SETTER(RxPluginsRxJavaSchedulersHookTest_$1, val$threadRef_, JavaUtilConcurrentAtomicAtomicReference *)

__attribute__((unused)) static void RxPluginsRxJavaSchedulersHookTest_$1_initWithJavaUtilConcurrentAtomicAtomicReference_(RxPluginsRxJavaSchedulersHookTest_$1 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0);

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$1 *new_RxPluginsRxJavaSchedulersHookTest_$1_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$1 *create_RxPluginsRxJavaSchedulersHookTest_$1_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0);

@interface RxPluginsRxJavaSchedulersHookTest_$2 : NSObject < RxFunctionsAction0 > {
 @public
  JavaUtilConcurrentAtomicAtomicReference *val$threadRef_;
  JavaUtilConcurrentCountDownLatch *val$latch_;
}

- (void)call;

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0
                           withJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$1;

@end

J2OBJC_EMPTY_STATIC_INIT(RxPluginsRxJavaSchedulersHookTest_$2)

J2OBJC_FIELD_SETTER(RxPluginsRxJavaSchedulersHookTest_$2, val$threadRef_, JavaUtilConcurrentAtomicAtomicReference *)
J2OBJC_FIELD_SETTER(RxPluginsRxJavaSchedulersHookTest_$2, val$latch_, JavaUtilConcurrentCountDownLatch *)

__attribute__((unused)) static void RxPluginsRxJavaSchedulersHookTest_$2_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(RxPluginsRxJavaSchedulersHookTest_$2 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1);

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$2 *new_RxPluginsRxJavaSchedulersHookTest_$2_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$2 *create_RxPluginsRxJavaSchedulersHookTest_$2_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1);

@interface RxPluginsRxJavaSchedulersHookTest_$3 : NSObject < JavaUtilConcurrentThreadFactory > {
 @public
  JavaUtilConcurrentAtomicAtomicReference *val$threadRef_;
}

- (JavaLangThread *)newThreadWithJavaLangRunnable:(id<JavaLangRunnable>)r OBJC_METHOD_FAMILY_NONE;

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0;

@end

J2OBJC_EMPTY_STATIC_INIT(RxPluginsRxJavaSchedulersHookTest_$3)

J2OBJC_FIELD_SETTER(RxPluginsRxJavaSchedulersHookTest_$3, val$threadRef_, JavaUtilConcurrentAtomicAtomicReference *)

__attribute__((unused)) static void RxPluginsRxJavaSchedulersHookTest_$3_initWithJavaUtilConcurrentAtomicAtomicReference_(RxPluginsRxJavaSchedulersHookTest_$3 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0);

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$3 *new_RxPluginsRxJavaSchedulersHookTest_$3_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$3 *create_RxPluginsRxJavaSchedulersHookTest_$3_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0);

@interface RxPluginsRxJavaSchedulersHookTest_$4 : NSObject < RxFunctionsAction0 > {
 @public
  JavaUtilConcurrentAtomicAtomicReference *val$threadRef_;
  JavaUtilConcurrentCountDownLatch *val$latch_;
}

- (void)call;

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0
                           withJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$1;

@end

J2OBJC_EMPTY_STATIC_INIT(RxPluginsRxJavaSchedulersHookTest_$4)

J2OBJC_FIELD_SETTER(RxPluginsRxJavaSchedulersHookTest_$4, val$threadRef_, JavaUtilConcurrentAtomicAtomicReference *)
J2OBJC_FIELD_SETTER(RxPluginsRxJavaSchedulersHookTest_$4, val$latch_, JavaUtilConcurrentCountDownLatch *)

__attribute__((unused)) static void RxPluginsRxJavaSchedulersHookTest_$4_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(RxPluginsRxJavaSchedulersHookTest_$4 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1);

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$4 *new_RxPluginsRxJavaSchedulersHookTest_$4_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$4 *create_RxPluginsRxJavaSchedulersHookTest_$4_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1);

@interface RxPluginsRxJavaSchedulersHookTest_$5 : NSObject < JavaUtilConcurrentThreadFactory > {
 @public
  JavaUtilConcurrentAtomicAtomicReference *val$threadRef_;
}

- (JavaLangThread *)newThreadWithJavaLangRunnable:(id<JavaLangRunnable>)r OBJC_METHOD_FAMILY_NONE;

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0;

@end

J2OBJC_EMPTY_STATIC_INIT(RxPluginsRxJavaSchedulersHookTest_$5)

J2OBJC_FIELD_SETTER(RxPluginsRxJavaSchedulersHookTest_$5, val$threadRef_, JavaUtilConcurrentAtomicAtomicReference *)

__attribute__((unused)) static void RxPluginsRxJavaSchedulersHookTest_$5_initWithJavaUtilConcurrentAtomicAtomicReference_(RxPluginsRxJavaSchedulersHookTest_$5 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0);

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$5 *new_RxPluginsRxJavaSchedulersHookTest_$5_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$5 *create_RxPluginsRxJavaSchedulersHookTest_$5_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0);

@interface RxPluginsRxJavaSchedulersHookTest_$6 : NSObject < RxFunctionsAction0 > {
 @public
  JavaUtilConcurrentAtomicAtomicReference *val$threadRef_;
  JavaUtilConcurrentCountDownLatch *val$latch_;
}

- (void)call;

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0
                           withJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$1;

@end

J2OBJC_EMPTY_STATIC_INIT(RxPluginsRxJavaSchedulersHookTest_$6)

J2OBJC_FIELD_SETTER(RxPluginsRxJavaSchedulersHookTest_$6, val$threadRef_, JavaUtilConcurrentAtomicAtomicReference *)
J2OBJC_FIELD_SETTER(RxPluginsRxJavaSchedulersHookTest_$6, val$latch_, JavaUtilConcurrentCountDownLatch *)

__attribute__((unused)) static void RxPluginsRxJavaSchedulersHookTest_$6_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(RxPluginsRxJavaSchedulersHookTest_$6 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1);

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$6 *new_RxPluginsRxJavaSchedulersHookTest_$6_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxPluginsRxJavaSchedulersHookTest_$6 *create_RxPluginsRxJavaSchedulersHookTest_$6_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1);

@implementation RxPluginsRxJavaSchedulersHookTest

- (void)schedulerFactoriesDisallowNull {
  @try {
    RxPluginsRxJavaSchedulersHook_createComputationSchedulerWithJavaUtilConcurrentThreadFactory_(nil);
    OrgJunitAssert_fail();
  }
  @catch (JavaLangNullPointerException *e) {
    OrgJunitAssert_assertEqualsWithId_withId_(@"threadFactory == null", [((JavaLangNullPointerException *) nil_chk(e)) getMessage]);
  }
  @try {
    RxPluginsRxJavaSchedulersHook_createIoSchedulerWithJavaUtilConcurrentThreadFactory_(nil);
    OrgJunitAssert_fail();
  }
  @catch (JavaLangNullPointerException *e) {
    OrgJunitAssert_assertEqualsWithId_withId_(@"threadFactory == null", [((JavaLangNullPointerException *) nil_chk(e)) getMessage]);
  }
  @try {
    RxPluginsRxJavaSchedulersHook_createNewThreadSchedulerWithJavaUtilConcurrentThreadFactory_(nil);
    OrgJunitAssert_fail();
  }
  @catch (JavaLangNullPointerException *e) {
    OrgJunitAssert_assertEqualsWithId_withId_(@"threadFactory == null", [((JavaLangNullPointerException *) nil_chk(e)) getMessage]);
  }
}

- (void)computationSchedulerUsesSuppliedThreadFactory {
  JavaUtilConcurrentAtomicAtomicReference *threadRef = create_JavaUtilConcurrentAtomicAtomicReference_init();
  id<JavaUtilConcurrentThreadFactory> threadFactory = create_RxPluginsRxJavaSchedulersHookTest_$1_initWithJavaUtilConcurrentAtomicAtomicReference_(threadRef);
  RxScheduler *scheduler = RxPluginsRxJavaSchedulersHook_createComputationSchedulerWithJavaUtilConcurrentThreadFactory_(threadFactory);
  RxScheduler_Worker *worker = [((RxScheduler *) nil_chk(scheduler)) createWorker];
  JavaUtilConcurrentCountDownLatch *latch = create_JavaUtilConcurrentCountDownLatch_initWithInt_(1);
  [((RxScheduler_Worker *) nil_chk(worker)) scheduleWithRxFunctionsAction0:create_RxPluginsRxJavaSchedulersHookTest_$2_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(threadRef, latch)];
  OrgJunitAssert_assertTrueWithBoolean_([latch awaitWithLong:10 withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, SECONDS)]);
  if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:scheduler]) {
    [((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(scheduler, RxInternalSchedulersSchedulerLifecycle_class_())) shutdown];
  }
}

- (void)ioSchedulerUsesSuppliedThreadFactory {
  JavaUtilConcurrentAtomicAtomicReference *threadRef = create_JavaUtilConcurrentAtomicAtomicReference_init();
  id<JavaUtilConcurrentThreadFactory> threadFactory = create_RxPluginsRxJavaSchedulersHookTest_$3_initWithJavaUtilConcurrentAtomicAtomicReference_(threadRef);
  RxScheduler *scheduler = RxPluginsRxJavaSchedulersHook_createIoSchedulerWithJavaUtilConcurrentThreadFactory_(threadFactory);
  RxScheduler_Worker *worker = [((RxScheduler *) nil_chk(scheduler)) createWorker];
  JavaUtilConcurrentCountDownLatch *latch = create_JavaUtilConcurrentCountDownLatch_initWithInt_(1);
  [((RxScheduler_Worker *) nil_chk(worker)) scheduleWithRxFunctionsAction0:create_RxPluginsRxJavaSchedulersHookTest_$4_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(threadRef, latch)];
  OrgJunitAssert_assertTrueWithBoolean_([latch awaitWithLong:10 withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, SECONDS)]);
  if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:scheduler]) {
    [((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(scheduler, RxInternalSchedulersSchedulerLifecycle_class_())) shutdown];
  }
}

- (void)newThreadSchedulerUsesSuppliedThreadFactory {
  JavaUtilConcurrentAtomicAtomicReference *threadRef = create_JavaUtilConcurrentAtomicAtomicReference_init();
  id<JavaUtilConcurrentThreadFactory> threadFactory = create_RxPluginsRxJavaSchedulersHookTest_$5_initWithJavaUtilConcurrentAtomicAtomicReference_(threadRef);
  RxScheduler *scheduler = RxPluginsRxJavaSchedulersHook_createNewThreadSchedulerWithJavaUtilConcurrentThreadFactory_(threadFactory);
  RxScheduler_Worker *worker = [((RxScheduler *) nil_chk(scheduler)) createWorker];
  JavaUtilConcurrentCountDownLatch *latch = create_JavaUtilConcurrentCountDownLatch_initWithInt_(1);
  [((RxScheduler_Worker *) nil_chk(worker)) scheduleWithRxFunctionsAction0:create_RxPluginsRxJavaSchedulersHookTest_$6_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(threadRef, latch)];
  OrgJunitAssert_assertTrueWithBoolean_([latch awaitWithLong:10 withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, SECONDS)]);
  if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:scheduler]) {
    [((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(scheduler, RxInternalSchedulersSchedulerLifecycle_class_())) shutdown];
  }
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  RxPluginsRxJavaSchedulersHookTest_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x1, -1, -1, -1, -1, 0, -1 },
    { NULL, "V", 0x1, -1, -1, 1, -1, 2, -1 },
    { NULL, "V", 0x1, -1, -1, 1, -1, 3, -1 },
    { NULL, "V", 0x1, -1, -1, 1, -1, 4, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(schedulerFactoriesDisallowNull);
  methods[1].selector = @selector(computationSchedulerUsesSuppliedThreadFactory);
  methods[2].selector = @selector(ioSchedulerUsesSuppliedThreadFactory);
  methods[3].selector = @selector(newThreadSchedulerUsesSuppliedThreadFactory);
  methods[4].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { (void *)&RxPluginsRxJavaSchedulersHookTest__Annotations$0, "LJavaLangInterruptedException;", (void *)&RxPluginsRxJavaSchedulersHookTest__Annotations$1, (void *)&RxPluginsRxJavaSchedulersHookTest__Annotations$2, (void *)&RxPluginsRxJavaSchedulersHookTest__Annotations$3 };
  static const J2ObjcClassInfo _RxPluginsRxJavaSchedulersHookTest = { "RxJavaSchedulersHookTest", "rx.plugins", ptrTable, methods, NULL, 7, 0x11, 5, 0, -1, -1, -1, -1, -1 };
  return &_RxPluginsRxJavaSchedulersHookTest;
}

@end

void RxPluginsRxJavaSchedulersHookTest_init(RxPluginsRxJavaSchedulersHookTest *self) {
  NSObject_init(self);
}

RxPluginsRxJavaSchedulersHookTest *new_RxPluginsRxJavaSchedulersHookTest_init() {
  J2OBJC_NEW_IMPL(RxPluginsRxJavaSchedulersHookTest, init)
}

RxPluginsRxJavaSchedulersHookTest *create_RxPluginsRxJavaSchedulersHookTest_init() {
  J2OBJC_CREATE_IMPL(RxPluginsRxJavaSchedulersHookTest, init)
}

IOSObjectArray *RxPluginsRxJavaSchedulersHookTest__Annotations$0() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_OrgJunitTest(OrgJunitTest_None_class_(), 0) } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

IOSObjectArray *RxPluginsRxJavaSchedulersHookTest__Annotations$1() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_OrgJunitTest(OrgJunitTest_None_class_(), 0) } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

IOSObjectArray *RxPluginsRxJavaSchedulersHookTest__Annotations$2() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_OrgJunitTest(OrgJunitTest_None_class_(), 0) } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

IOSObjectArray *RxPluginsRxJavaSchedulersHookTest__Annotations$3() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_OrgJunitTest(OrgJunitTest_None_class_(), 0) } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxPluginsRxJavaSchedulersHookTest)

@implementation RxPluginsRxJavaSchedulersHookTest_$1

- (JavaLangThread *)newThreadWithJavaLangRunnable:(id<JavaLangRunnable>)r {
  JavaLangThread *thread = create_JavaLangThread_initWithJavaLangRunnable_(r);
  [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(val$threadRef_)) setWithId:thread];
  return thread;
}

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0 {
  RxPluginsRxJavaSchedulersHookTest_$1_initWithJavaUtilConcurrentAtomicAtomicReference_(self, capture$0);
  return self;
}

- (void)dealloc {
  RELEASE_(val$threadRef_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LJavaLangThread;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 2, -1, 3, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(newThreadWithJavaLangRunnable:);
  methods[1].selector = @selector(initWithJavaUtilConcurrentAtomicAtomicReference:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$threadRef_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1012, -1, -1, 4, -1 },
  };
  static const void *ptrTable[] = { "newThread", "LJavaLangRunnable;", "LJavaUtilConcurrentAtomicAtomicReference;", "(Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;)V", "Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;", "LRxPluginsRxJavaSchedulersHookTest;", "computationSchedulerUsesSuppliedThreadFactory" };
  static const J2ObjcClassInfo _RxPluginsRxJavaSchedulersHookTest_$1 = { "", "rx.plugins", ptrTable, methods, fields, 7, 0x8008, 2, 1, 5, -1, 6, -1, -1 };
  return &_RxPluginsRxJavaSchedulersHookTest_$1;
}

@end

void RxPluginsRxJavaSchedulersHookTest_$1_initWithJavaUtilConcurrentAtomicAtomicReference_(RxPluginsRxJavaSchedulersHookTest_$1 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0) {
  JreStrongAssign(&self->val$threadRef_, capture$0);
  NSObject_init(self);
}

RxPluginsRxJavaSchedulersHookTest_$1 *new_RxPluginsRxJavaSchedulersHookTest_$1_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0) {
  J2OBJC_NEW_IMPL(RxPluginsRxJavaSchedulersHookTest_$1, initWithJavaUtilConcurrentAtomicAtomicReference_, capture$0)
}

RxPluginsRxJavaSchedulersHookTest_$1 *create_RxPluginsRxJavaSchedulersHookTest_$1_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0) {
  J2OBJC_CREATE_IMPL(RxPluginsRxJavaSchedulersHookTest_$1, initWithJavaUtilConcurrentAtomicAtomicReference_, capture$0)
}

@implementation RxPluginsRxJavaSchedulersHookTest_$2

- (void)call {
  OrgJunitAssert_assertSameWithId_withId_([((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(val$threadRef_)) get], JavaLangThread_currentThread());
  [((JavaUtilConcurrentCountDownLatch *) nil_chk(val$latch_)) countDown];
}

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0
                           withJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$1 {
  RxPluginsRxJavaSchedulersHookTest_$2_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(self, capture$0, capture$1);
  return self;
}

- (void)dealloc {
  RELEASE_(val$threadRef_);
  RELEASE_(val$latch_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(call);
  methods[1].selector = @selector(initWithJavaUtilConcurrentAtomicAtomicReference:withJavaUtilConcurrentCountDownLatch:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$threadRef_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1012, -1, -1, 2, -1 },
    { "val$latch_", "LJavaUtilConcurrentCountDownLatch;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilConcurrentAtomicAtomicReference;LJavaUtilConcurrentCountDownLatch;", "(Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;Ljava/util/concurrent/CountDownLatch;)V", "Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;", "LRxPluginsRxJavaSchedulersHookTest;", "computationSchedulerUsesSuppliedThreadFactory" };
  static const J2ObjcClassInfo _RxPluginsRxJavaSchedulersHookTest_$2 = { "", "rx.plugins", ptrTable, methods, fields, 7, 0x8008, 2, 2, 3, -1, 4, -1, -1 };
  return &_RxPluginsRxJavaSchedulersHookTest_$2;
}

@end

void RxPluginsRxJavaSchedulersHookTest_$2_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(RxPluginsRxJavaSchedulersHookTest_$2 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) {
  JreStrongAssign(&self->val$threadRef_, capture$0);
  JreStrongAssign(&self->val$latch_, capture$1);
  NSObject_init(self);
}

RxPluginsRxJavaSchedulersHookTest_$2 *new_RxPluginsRxJavaSchedulersHookTest_$2_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) {
  J2OBJC_NEW_IMPL(RxPluginsRxJavaSchedulersHookTest_$2, initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_, capture$0, capture$1)
}

RxPluginsRxJavaSchedulersHookTest_$2 *create_RxPluginsRxJavaSchedulersHookTest_$2_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) {
  J2OBJC_CREATE_IMPL(RxPluginsRxJavaSchedulersHookTest_$2, initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_, capture$0, capture$1)
}

@implementation RxPluginsRxJavaSchedulersHookTest_$3

- (JavaLangThread *)newThreadWithJavaLangRunnable:(id<JavaLangRunnable>)r {
  JavaLangThread *thread = create_JavaLangThread_initWithJavaLangRunnable_(r);
  [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(val$threadRef_)) setWithId:thread];
  return thread;
}

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0 {
  RxPluginsRxJavaSchedulersHookTest_$3_initWithJavaUtilConcurrentAtomicAtomicReference_(self, capture$0);
  return self;
}

- (void)dealloc {
  RELEASE_(val$threadRef_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LJavaLangThread;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 2, -1, 3, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(newThreadWithJavaLangRunnable:);
  methods[1].selector = @selector(initWithJavaUtilConcurrentAtomicAtomicReference:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$threadRef_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1012, -1, -1, 4, -1 },
  };
  static const void *ptrTable[] = { "newThread", "LJavaLangRunnable;", "LJavaUtilConcurrentAtomicAtomicReference;", "(Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;)V", "Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;", "LRxPluginsRxJavaSchedulersHookTest;", "ioSchedulerUsesSuppliedThreadFactory" };
  static const J2ObjcClassInfo _RxPluginsRxJavaSchedulersHookTest_$3 = { "", "rx.plugins", ptrTable, methods, fields, 7, 0x8008, 2, 1, 5, -1, 6, -1, -1 };
  return &_RxPluginsRxJavaSchedulersHookTest_$3;
}

@end

void RxPluginsRxJavaSchedulersHookTest_$3_initWithJavaUtilConcurrentAtomicAtomicReference_(RxPluginsRxJavaSchedulersHookTest_$3 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0) {
  JreStrongAssign(&self->val$threadRef_, capture$0);
  NSObject_init(self);
}

RxPluginsRxJavaSchedulersHookTest_$3 *new_RxPluginsRxJavaSchedulersHookTest_$3_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0) {
  J2OBJC_NEW_IMPL(RxPluginsRxJavaSchedulersHookTest_$3, initWithJavaUtilConcurrentAtomicAtomicReference_, capture$0)
}

RxPluginsRxJavaSchedulersHookTest_$3 *create_RxPluginsRxJavaSchedulersHookTest_$3_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0) {
  J2OBJC_CREATE_IMPL(RxPluginsRxJavaSchedulersHookTest_$3, initWithJavaUtilConcurrentAtomicAtomicReference_, capture$0)
}

@implementation RxPluginsRxJavaSchedulersHookTest_$4

- (void)call {
  OrgJunitAssert_assertSameWithId_withId_([((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(val$threadRef_)) get], JavaLangThread_currentThread());
  [((JavaUtilConcurrentCountDownLatch *) nil_chk(val$latch_)) countDown];
}

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0
                           withJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$1 {
  RxPluginsRxJavaSchedulersHookTest_$4_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(self, capture$0, capture$1);
  return self;
}

- (void)dealloc {
  RELEASE_(val$threadRef_);
  RELEASE_(val$latch_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(call);
  methods[1].selector = @selector(initWithJavaUtilConcurrentAtomicAtomicReference:withJavaUtilConcurrentCountDownLatch:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$threadRef_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1012, -1, -1, 2, -1 },
    { "val$latch_", "LJavaUtilConcurrentCountDownLatch;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilConcurrentAtomicAtomicReference;LJavaUtilConcurrentCountDownLatch;", "(Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;Ljava/util/concurrent/CountDownLatch;)V", "Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;", "LRxPluginsRxJavaSchedulersHookTest;", "ioSchedulerUsesSuppliedThreadFactory" };
  static const J2ObjcClassInfo _RxPluginsRxJavaSchedulersHookTest_$4 = { "", "rx.plugins", ptrTable, methods, fields, 7, 0x8008, 2, 2, 3, -1, 4, -1, -1 };
  return &_RxPluginsRxJavaSchedulersHookTest_$4;
}

@end

void RxPluginsRxJavaSchedulersHookTest_$4_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(RxPluginsRxJavaSchedulersHookTest_$4 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) {
  JreStrongAssign(&self->val$threadRef_, capture$0);
  JreStrongAssign(&self->val$latch_, capture$1);
  NSObject_init(self);
}

RxPluginsRxJavaSchedulersHookTest_$4 *new_RxPluginsRxJavaSchedulersHookTest_$4_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) {
  J2OBJC_NEW_IMPL(RxPluginsRxJavaSchedulersHookTest_$4, initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_, capture$0, capture$1)
}

RxPluginsRxJavaSchedulersHookTest_$4 *create_RxPluginsRxJavaSchedulersHookTest_$4_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) {
  J2OBJC_CREATE_IMPL(RxPluginsRxJavaSchedulersHookTest_$4, initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_, capture$0, capture$1)
}

@implementation RxPluginsRxJavaSchedulersHookTest_$5

- (JavaLangThread *)newThreadWithJavaLangRunnable:(id<JavaLangRunnable>)r {
  JavaLangThread *thread = create_JavaLangThread_initWithJavaLangRunnable_(r);
  [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(val$threadRef_)) setWithId:thread];
  return thread;
}

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0 {
  RxPluginsRxJavaSchedulersHookTest_$5_initWithJavaUtilConcurrentAtomicAtomicReference_(self, capture$0);
  return self;
}

- (void)dealloc {
  RELEASE_(val$threadRef_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LJavaLangThread;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 2, -1, 3, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(newThreadWithJavaLangRunnable:);
  methods[1].selector = @selector(initWithJavaUtilConcurrentAtomicAtomicReference:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$threadRef_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1012, -1, -1, 4, -1 },
  };
  static const void *ptrTable[] = { "newThread", "LJavaLangRunnable;", "LJavaUtilConcurrentAtomicAtomicReference;", "(Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;)V", "Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;", "LRxPluginsRxJavaSchedulersHookTest;", "newThreadSchedulerUsesSuppliedThreadFactory" };
  static const J2ObjcClassInfo _RxPluginsRxJavaSchedulersHookTest_$5 = { "", "rx.plugins", ptrTable, methods, fields, 7, 0x8008, 2, 1, 5, -1, 6, -1, -1 };
  return &_RxPluginsRxJavaSchedulersHookTest_$5;
}

@end

void RxPluginsRxJavaSchedulersHookTest_$5_initWithJavaUtilConcurrentAtomicAtomicReference_(RxPluginsRxJavaSchedulersHookTest_$5 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0) {
  JreStrongAssign(&self->val$threadRef_, capture$0);
  NSObject_init(self);
}

RxPluginsRxJavaSchedulersHookTest_$5 *new_RxPluginsRxJavaSchedulersHookTest_$5_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0) {
  J2OBJC_NEW_IMPL(RxPluginsRxJavaSchedulersHookTest_$5, initWithJavaUtilConcurrentAtomicAtomicReference_, capture$0)
}

RxPluginsRxJavaSchedulersHookTest_$5 *create_RxPluginsRxJavaSchedulersHookTest_$5_initWithJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0) {
  J2OBJC_CREATE_IMPL(RxPluginsRxJavaSchedulersHookTest_$5, initWithJavaUtilConcurrentAtomicAtomicReference_, capture$0)
}

@implementation RxPluginsRxJavaSchedulersHookTest_$6

- (void)call {
  OrgJunitAssert_assertSameWithId_withId_([((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(val$threadRef_)) get], JavaLangThread_currentThread());
  [((JavaUtilConcurrentCountDownLatch *) nil_chk(val$latch_)) countDown];
}

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0
                           withJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$1 {
  RxPluginsRxJavaSchedulersHookTest_$6_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(self, capture$0, capture$1);
  return self;
}

- (void)dealloc {
  RELEASE_(val$threadRef_);
  RELEASE_(val$latch_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(call);
  methods[1].selector = @selector(initWithJavaUtilConcurrentAtomicAtomicReference:withJavaUtilConcurrentCountDownLatch:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$threadRef_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1012, -1, -1, 2, -1 },
    { "val$latch_", "LJavaUtilConcurrentCountDownLatch;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilConcurrentAtomicAtomicReference;LJavaUtilConcurrentCountDownLatch;", "(Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;Ljava/util/concurrent/CountDownLatch;)V", "Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Thread;>;", "LRxPluginsRxJavaSchedulersHookTest;", "newThreadSchedulerUsesSuppliedThreadFactory" };
  static const J2ObjcClassInfo _RxPluginsRxJavaSchedulersHookTest_$6 = { "", "rx.plugins", ptrTable, methods, fields, 7, 0x8008, 2, 2, 3, -1, 4, -1, -1 };
  return &_RxPluginsRxJavaSchedulersHookTest_$6;
}

@end

void RxPluginsRxJavaSchedulersHookTest_$6_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(RxPluginsRxJavaSchedulersHookTest_$6 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) {
  JreStrongAssign(&self->val$threadRef_, capture$0);
  JreStrongAssign(&self->val$latch_, capture$1);
  NSObject_init(self);
}

RxPluginsRxJavaSchedulersHookTest_$6 *new_RxPluginsRxJavaSchedulersHookTest_$6_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) {
  J2OBJC_NEW_IMPL(RxPluginsRxJavaSchedulersHookTest_$6, initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_, capture$0, capture$1)
}

RxPluginsRxJavaSchedulersHookTest_$6 *create_RxPluginsRxJavaSchedulersHookTest_$6_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1) {
  J2OBJC_CREATE_IMPL(RxPluginsRxJavaSchedulersHookTest_$6, initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_, capture$0, capture$1)
}
