//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel-doppl/RxJava/src/test/java/rx/schedulers/SchedulerTests.java
//

#include "J2ObjC_source.h"
#include "RxCapturingUncaughtExceptionHandler.h"
#include "RxObservable.h"
#include "RxObserver.h"
#include "RxScheduler.h"
#include "RxSchedulersSchedulerTests.h"
#include "RxSubscription.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Thread.h"
#include "java/util/concurrent/CountDownLatch.h"
#include "java/util/concurrent/TimeUnit.h"
#include "org/junit/Assert.h"

@interface RxSchedulersSchedulerTests ()

- (instancetype)init;

@end

__attribute__((unused)) static void RxSchedulersSchedulerTests_init(RxSchedulersSchedulerTests *self);

__attribute__((unused)) static RxSchedulersSchedulerTests *new_RxSchedulersSchedulerTests_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static RxSchedulersSchedulerTests *create_RxSchedulersSchedulerTests_init();

@interface RxSchedulersSchedulerTests_CapturingObserver : NSObject < RxObserver > {
 @public
  JavaUtilConcurrentCountDownLatch *completed_;
  jint errorCount_;
  jint nextCount_;
  NSException *error_;
}

- (void)onCompleted;

- (void)onErrorWithNSException:(NSException *)e;

- (void)onNextWithId:(id)t;

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSchedulersSchedulerTests_CapturingObserver)

J2OBJC_FIELD_SETTER(RxSchedulersSchedulerTests_CapturingObserver, completed_, JavaUtilConcurrentCountDownLatch *)
J2OBJC_FIELD_SETTER(RxSchedulersSchedulerTests_CapturingObserver, error_, NSException *)

__attribute__((unused)) static void RxSchedulersSchedulerTests_CapturingObserver_init(RxSchedulersSchedulerTests_CapturingObserver *self);

__attribute__((unused)) static RxSchedulersSchedulerTests_CapturingObserver *new_RxSchedulersSchedulerTests_CapturingObserver_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static RxSchedulersSchedulerTests_CapturingObserver *create_RxSchedulersSchedulerTests_CapturingObserver_init();

J2OBJC_TYPE_LITERAL_HEADER(RxSchedulersSchedulerTests_CapturingObserver)

@implementation RxSchedulersSchedulerTests

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  RxSchedulersSchedulerTests_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (void)testUnhandledErrorIsDeliveredToThreadHandlerWithRxScheduler:(RxScheduler *)scheduler {
  RxSchedulersSchedulerTests_testUnhandledErrorIsDeliveredToThreadHandlerWithRxScheduler_(scheduler);
}

+ (void)testHandledErrorIsNotDeliveredToThreadHandlerWithRxScheduler:(RxScheduler *)scheduler {
  RxSchedulersSchedulerTests_testHandledErrorIsNotDeliveredToThreadHandlerWithRxScheduler_(scheduler);
}

+ (void)testCancelledRetentionWithRxScheduler_Worker:(RxScheduler_Worker *)w
                                         withBoolean:(jboolean)periodic {
  RxSchedulersSchedulerTests_testCancelledRetentionWithRxScheduler_Worker_withBoolean_(w, periodic);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 0, 1, 2, -1, -1, -1 },
    { NULL, "V", 0x9, 3, 1, 2, -1, -1, -1 },
    { NULL, "V", 0x9, 4, 5, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(testUnhandledErrorIsDeliveredToThreadHandlerWithRxScheduler:);
  methods[2].selector = @selector(testHandledErrorIsNotDeliveredToThreadHandlerWithRxScheduler:);
  methods[3].selector = @selector(testCancelledRetentionWithRxScheduler_Worker:withBoolean:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "testUnhandledErrorIsDeliveredToThreadHandler", "LRxScheduler;", "LJavaLangInterruptedException;", "testHandledErrorIsNotDeliveredToThreadHandler", "testCancelledRetention", "LRxScheduler_Worker;Z", "LRxSchedulersSchedulerTests_CapturingObserver;" };
  static const J2ObjcClassInfo _RxSchedulersSchedulerTests = { "SchedulerTests", "rx.schedulers", ptrTable, methods, NULL, 7, 0x11, 4, 0, -1, 6, -1, -1, -1 };
  return &_RxSchedulersSchedulerTests;
}

@end

void RxSchedulersSchedulerTests_init(RxSchedulersSchedulerTests *self) {
  NSObject_init(self);
}

RxSchedulersSchedulerTests *new_RxSchedulersSchedulerTests_init() {
  J2OBJC_NEW_IMPL(RxSchedulersSchedulerTests, init)
}

RxSchedulersSchedulerTests *create_RxSchedulersSchedulerTests_init() {
  J2OBJC_CREATE_IMPL(RxSchedulersSchedulerTests, init)
}

void RxSchedulersSchedulerTests_testUnhandledErrorIsDeliveredToThreadHandlerWithRxScheduler_(RxScheduler *scheduler) {
  RxSchedulersSchedulerTests_initialize();
  id<JavaLangThread_UncaughtExceptionHandler> originalHandler = JavaLangThread_getDefaultUncaughtExceptionHandler();
  @try {
    RxCapturingUncaughtExceptionHandler *handler = create_RxCapturingUncaughtExceptionHandler_init();
    JavaLangThread_setDefaultUncaughtExceptionHandlerWithJavaLangThread_UncaughtExceptionHandler_(handler);
    JavaLangIllegalStateException *error = create_JavaLangIllegalStateException_initWithNSString_(@"Should be delivered to handler");
    [((RxObservable *) nil_chk([((RxObservable *) nil_chk(RxObservable_errorWithNSException_(error))) subscribeOnWithRxScheduler:scheduler])) subscribe];
    if (![((JavaUtilConcurrentCountDownLatch *) nil_chk(handler->completed_)) awaitWithLong:3 withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, SECONDS)]) {
      OrgJunitAssert_failWithNSString_(@"timed out");
    }
    OrgJunitAssert_assertEqualsWithNSString_withLong_withLong_(@"Should have received exactly 1 exception", 1, handler->count_);
    NSException *cause = handler->caught_;
    while (cause != nil) {
      if ([error isEqual:cause]) break;
      if (cause == [cause getCause]) break;
      cause = [cause getCause];
    }
    OrgJunitAssert_assertEqualsWithNSString_withId_withId_(@"Our error should have been delivered to the handler", error, cause);
  }
  @finally {
    JavaLangThread_setDefaultUncaughtExceptionHandlerWithJavaLangThread_UncaughtExceptionHandler_(originalHandler);
  }
}

void RxSchedulersSchedulerTests_testHandledErrorIsNotDeliveredToThreadHandlerWithRxScheduler_(RxScheduler *scheduler) {
  RxSchedulersSchedulerTests_initialize();
  id<JavaLangThread_UncaughtExceptionHandler> originalHandler = JavaLangThread_getDefaultUncaughtExceptionHandler();
  @try {
    RxCapturingUncaughtExceptionHandler *handler = create_RxCapturingUncaughtExceptionHandler_init();
    RxSchedulersSchedulerTests_CapturingObserver *observer = create_RxSchedulersSchedulerTests_CapturingObserver_init();
    JavaLangThread_setDefaultUncaughtExceptionHandlerWithJavaLangThread_UncaughtExceptionHandler_(handler);
    JavaLangIllegalStateException *error = create_JavaLangIllegalStateException_initWithNSString_(@"Should be delivered to handler");
    [((RxObservable *) nil_chk([((RxObservable *) nil_chk(RxObservable_errorWithNSException_(error))) subscribeOnWithRxScheduler:scheduler])) subscribeWithRxObserver:observer];
    if (![((JavaUtilConcurrentCountDownLatch *) nil_chk(observer->completed_)) awaitWithLong:3 withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, SECONDS)]) {
      OrgJunitAssert_failWithNSString_(@"timed out");
    }
    OrgJunitAssert_assertEqualsWithNSString_withLong_withLong_(@"Handler should not have received anything", 0, handler->count_);
    OrgJunitAssert_assertEqualsWithNSString_withLong_withLong_(@"Observer should have received an error", 1, observer->errorCount_);
    OrgJunitAssert_assertEqualsWithNSString_withLong_withLong_(@"Observer should not have received a next value", 0, observer->nextCount_);
    NSException *cause = observer->error_;
    while (cause != nil) {
      if ([error isEqual:cause]) break;
      if (cause == [cause getCause]) break;
      cause = [cause getCause];
    }
    OrgJunitAssert_assertEqualsWithNSString_withId_withId_(@"Our error should have been delivered to the observer", error, cause);
  }
  @finally {
    JavaLangThread_setDefaultUncaughtExceptionHandlerWithJavaLangThread_UncaughtExceptionHandler_(originalHandler);
  }
}

void RxSchedulersSchedulerTests_testCancelledRetentionWithRxScheduler_Worker_withBoolean_(RxScheduler_Worker *w, jboolean periodic) {
  RxSchedulersSchedulerTests_initialize();
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxSchedulersSchedulerTests)

@implementation RxSchedulersSchedulerTests_CapturingObserver

- (void)onCompleted {
}

- (void)onErrorWithNSException:(NSException *)e {
  errorCount_++;
  JreStrongAssign(&error_, e);
  [((JavaUtilConcurrentCountDownLatch *) nil_chk(completed_)) countDown];
}

- (void)onNextWithId:(id)t {
  nextCount_++;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  RxSchedulersSchedulerTests_CapturingObserver_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)dealloc {
  RELEASE_(completed_);
  RELEASE_(error_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, 4, -1, -1 },
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(onCompleted);
  methods[1].selector = @selector(onErrorWithNSException:);
  methods[2].selector = @selector(onNextWithId:);
  methods[3].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "completed_", "LJavaUtilConcurrentCountDownLatch;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "errorCount_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "nextCount_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "error_", "LNSException;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "onError", "LNSException;", "onNext", "LNSObject;", "(TT;)V", "LRxSchedulersSchedulerTests;", "<T:Ljava/lang/Object;>Ljava/lang/Object;Lrx/Observer<TT;>;" };
  static const J2ObjcClassInfo _RxSchedulersSchedulerTests_CapturingObserver = { "CapturingObserver", "rx.schedulers", ptrTable, methods, fields, 7, 0x1a, 4, 4, 5, -1, -1, 6, -1 };
  return &_RxSchedulersSchedulerTests_CapturingObserver;
}

@end

void RxSchedulersSchedulerTests_CapturingObserver_init(RxSchedulersSchedulerTests_CapturingObserver *self) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->completed_, new_JavaUtilConcurrentCountDownLatch_initWithInt_(1));
  self->errorCount_ = 0;
  self->nextCount_ = 0;
}

RxSchedulersSchedulerTests_CapturingObserver *new_RxSchedulersSchedulerTests_CapturingObserver_init() {
  J2OBJC_NEW_IMPL(RxSchedulersSchedulerTests_CapturingObserver, init)
}

RxSchedulersSchedulerTests_CapturingObserver *create_RxSchedulersSchedulerTests_CapturingObserver_init() {
  J2OBJC_CREATE_IMPL(RxSchedulersSchedulerTests_CapturingObserver, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxSchedulersSchedulerTests_CapturingObserver)
