/**
 * Copyright 2013 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.codegen;

import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;

import rx.util.functions.Func1;
import rx.util.functions.Function;
import rx.util.functions.FunctionLanguageAdaptor;

/**
 * Generate a class named {@code DYNAMIC_FUNC1_NAME}.  This class gets constructed in code generated by
 * {@code OneArgSubscribeOnMapMethodRewriter}.  It supports a chain of instanceof checks that determine which
 * native function class gets passed in, and converts it to an rx core {@code Action}. Contrast this with
 * the version in core {@code actionIdentity}, which needs no runtime checks - it's just an identity.
 *
 * Once the Func1 has been constructed, you can pass that into the core subscribeWithConversion(Map, Func1) to
 * apply the correct runtime checks/conversions.
 */
public class Func1Generator {

    private final ClassPool pool;
    private final FunctionLanguageAdaptor adaptor;

    public Func1Generator(ClassPool pool, FunctionLanguageAdaptor adaptor) {
        this.pool = pool;
        this.adaptor = adaptor;
    }
    
    static final String DYNAMIC_FUNC1_NAME = "Func1DynamicConverter";

    public CtClass createDynamicFunc1Class() throws CannotCompileException, NotFoundException {
        Class<?> func1Class = Func1.class;
        CtClass func1CtClass = pool.get(func1Class.getName());
        Class<?> funcClass = Function.class;
        CtClass funcCtClass = pool.get(funcClass.getName());
        CtClass objectCtClass = pool.get(Object.class.getName());
        CtClass[] params = new CtClass[1];
        params[0] = objectCtClass;

        CtClass conversionClass = pool.makeClass(DYNAMIC_FUNC1_NAME);
        StringBuffer methodBody = new StringBuffer();
        StringBuffer classCheckBranching = new StringBuffer();
        for (Class<?> nativeFunctionClass: adaptor.getAllClassesToRewrite()) {
            Class<?> actionAdaptorClass = adaptor.getActionClassRewritingMap().get(nativeFunctionClass);
            
            classCheckBranching.append("} else if ($1 instanceof " + nativeFunctionClass.getName() + ") {\n");
            classCheckBranching.append("return new " + actionAdaptorClass.getName() + "((" + nativeFunctionClass.getName() + ") $1);\n");
        }
        
        methodBody.append("{\n");
        methodBody.append("if ($1 instanceof " + funcClass.getName() + ") {\n");
        methodBody.append("return (" + funcClass.getName() + ") $1;\n");
        methodBody.append(classCheckBranching.toString());
        methodBody.append("} else {\n");
        methodBody.append("throw new RuntimeException(\"Can't convert from class : \" + $1.getClass().getName());\n");
        methodBody.append("}\n");
        methodBody.append("}\n");
        
        CtMethod callMethod = new CtMethod(objectCtClass, "call", params, conversionClass);
        callMethod.setModifiers(Modifier.PUBLIC);
        callMethod.setBody(methodBody.toString());
        conversionClass.addMethod(callMethod);
        conversionClass.addInterface(func1CtClass);
        int classModifiers = conversionClass.getModifiers();
        conversionClass.setModifiers(Modifier.PUBLIC);
        return conversionClass;
    }
}