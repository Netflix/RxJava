subprojects {
    if (!subprojects.empty) { // is a container
        return
    }

    description = name.capitalize().replaceAll("-\\w") { " " + (it.toUpperCase() - "-") }.replaceAll("Rxjava", "RxJava")

    apply plugin: 'java'
    apply plugin: 'osgi'

    repositories {
        mavenLocal()
        mavenCentral() // maven { url: 'http://jcenter.bintray.com' }
    }

    dependencies {
        if (project.path != ":rxjava-core") {
            compile project(':rxjava-core')
        }

        testCompile 'junit:junit-dep:4.10'
        testCompile 'org.mockito:mockito-core:1.8.5'
    }

    sourceCompatibility = JavaVersion.VERSION_1_6
    targetCompatibility = JavaVersion.VERSION_1_6

    status = project.hasProperty('preferredStatus') ? project.preferredStatus : (version.contains('SNAPSHOT') ? 'snapshot' : 'release')

    task sourcesJar(type: Jar, dependsOn: classes) {
        from sourceSets.main.allSource
        classifier 'sources'
        extension 'jar'
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        from javadoc.destinationDir
        classifier 'javadoc'
        extension 'jar'
    }

    jar {
        manifest {
            name = project.name
            instruction 'Bundle-Vendor', 'Netflix'
            instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava'
            if (project.path != ":rxjava-core") {
                instruction 'Fragment-Host', 'com.netflix.rxjava.core'
            }
        }
    }

    configurations {
        create("sources")
        create("javadoc")
        archives {
            extendsFrom configurations.sources
            extendsFrom configurations.javadoc
        }
    }

    // When outputing to an Ivy repo, we want to use the proper type field
    gradle.taskGraph.whenReady {
        def isNotMaven = !it.hasTask(project.uploadMavenCentral)
        if (isNotMaven) {
            def artifacts = project.configurations.sources.artifacts
            def sourceArtifact = artifacts.iterator().next()
            sourceArtifact.type = 'sources'
        }
    }

    artifacts {
        sources(sourcesJar) {
            // Weird Gradle quirk where type will be used for the extension, but only for sources
            type 'jar'
        }
        javadoc(javadocJar) {
            type 'javadoc'
        }
    }

    configurations {
        provided {
            description = 'much like compile, but indicates you expect the JDK or a container to provide it. It is only available on the compilation classpath, and is not transitive.'
            transitive = true
            visible = true
        }
    }

    sourceSets {
        main {
            compileClasspath += configurations.provided
            runtimeClasspath -= configurations.provided
        }
        test {
            compileClasspath += configurations.provided
            runtimeClasspath += configurations.provided
        }
        examples {
            compileClasspath += configurations.provided + main.output
        }
        perf {
            compileClasspath += configurations.provided + main.output
        }
    }

    configurations {
        examplesCompile.extendsFrom testCompile
        examplesRuntime.extendsFrom testRuntime
        perfCompile.extendsFrom testCompile
        perfRuntime.extendsFrom testRuntime
    }

    javadoc {
        options {
            doclet = "org.benjchristensen.doclet.DocletExclude"
            docletpath = [rootProject.file('gradle/doclet-exclude.jar')]
            stylesheetFile = rootProject.file('gradle/javadocStyleSheet.css')
            windowTitle = "$project.description Javadoc $project.version"
            addStringOption('top').value = '<h2 class="title" style="padding-top:40px">' + project.description + '</h2>'.toString()
        }
        classpath += configurations.provided
    }

    build {
        dependsOn examplesClasses
    }

    // Individual projects will apply specific language plugins which add to source setsâ€¦
    // do this late so we get those additions
    afterEvaluate {
        idea {
            module {
                [sourceSets.examples, sourceSets.perf].each {
                    [it.allSource.srcDirs, it.resources.srcDirs].each {
                        testSourceDirs += it
                    }
                }
                scopes.PROVIDED.plus += configurations.provided
            }
        }

        eclipse {
            classpath {
                plusConfigurations += configurations.provided
                downloadJavadoc = true
            }
        }
    }

}